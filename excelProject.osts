{"version":"0.3.0","body":"function main(workbook: ExcelScript.Workbook) {\n    const mainWorksheetName = \"Atividades\";\n    const outputWorksheetName = \"Timeline\";\n    const MAX_DAYS = 60;\n\n    interface Task {\n        project: string;\n        task: string;\n        status: string;\n        start: Date | null;\n        end: Date | null;\n    }\n\n    const mainSheet = workbook.getWorksheet(mainWorksheetName);\n    if (!mainSheet) {\n        console.log(`Planilha \"${mainWorksheetName}\" não encontrada.`);\n        return;\n    }\n\n    let outputSheet = workbook.getWorksheet(outputWorksheetName);\n    if (!outputSheet) {\n        outputSheet = workbook.addWorksheet(outputWorksheetName);\n    } else {\n        outputSheet.getUsedRange()?.clear();\n    }\n\n    const usedRange = mainSheet.getUsedRange();\n    if (!usedRange) {\n        console.log(\"Nenhum dado encontrado.\");\n        return;\n    }\n\n    const values = usedRange.getValues();\n    const headers = values[0] as string[];\n    const rows = values.slice(1);\n\n    const projectIdx = headers.findIndex((h) => h.toLowerCase() === \"project\");\n    const taskIdx = headers.findIndex((h) => h.toLowerCase() === \"task\");\n    const statusIdx = headers.findIndex((h) => h.toLowerCase() === \"status\");\n    const startIdx = headers.findIndex((h) => h.toLowerCase() === \"start\");\n    const endIdx = headers.findIndex((h) => h.toLowerCase() === \"finish\");\n\n    if (\n        projectIdx === -1 ||\n        taskIdx === -1 ||\n        statusIdx === -1 ||\n        startIdx === -1 ||\n        endIdx === -1\n    ) {\n        console.log(\"Colunas obrigatórias não encontradas.\");\n        return;\n    }\n\n    // Função para detectar se é Date\n    function isDate(value: unknown): value is Date {\n        return (\n            Object.prototype.toString.call(value) === \"[object Date]\" &&\n            !isNaN((value as Date).getTime())\n        );\n    }\n\n    // Função para converter valor Excel para Date (considera número e string)\n    function parseDate(value: unknown): Date | null {\n        if (typeof value === \"number\") {\n            const excelEpoch = new Date(Date.UTC(1899, 11, 30));\n            return new Date(excelEpoch.getTime() + value * 86400000);\n        }\n        if (isDate(value)) {\n            return value as Date;\n        }\n        if (typeof value === \"string\") {\n            const d = new Date(value);\n            return isNaN(d.getTime()) ? null : d;\n        }\n        return null;\n    }\n\n    const tasks: Task[] = [];\n\n    for (const row of rows) {\n        const project = row[projectIdx]?.toString().trim() || \"\";\n        const task = row[taskIdx]?.toString().trim() || \"\";\n        const status = row[statusIdx]?.toString().toLowerCase() || \"\";\n\n        const start = parseDate(row[startIdx]);\n        const end = parseDate(row[endIdx]);\n\n        if (!project || !task) continue;\n\n        tasks.push({ project, task, status, start, end });\n    }\n\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    // Ajustar startDate para a menor data entre hoje e a menor data de início nas tasks\n    let minStartDate = today;\n    for (const task of tasks) {\n        if (task.start && task.start < minStartDate) {\n            minStartDate = new Date(task.start);\n            minStartDate.setHours(0, 0, 0, 0);\n        }\n    }\n    const startDate = new Date(minStartDate);\n\n    const endDate = new Date(startDate);\n    endDate.setDate(endDate.getDate() + MAX_DAYS);\n\n    const daysRange: string[] = [];\n    const dateMap: { [key: string]: number } = {};\n\n    for (let d = 0; d <= MAX_DAYS; d++) {\n        const date = new Date(startDate);\n        date.setDate(date.getDate() + d);\n        const dateStr = date.toLocaleDateString(\"pt-BR\");\n        daysRange.push(dateStr);\n        dateMap[dateStr] = d;\n    }\n\n    const headerRow = [\"PROJECT\", \"TASK\", \"STATUS\", ...daysRange];\n    outputSheet.getRangeByIndexes(0, 0, 1, headerRow.length).setValues([headerRow]);\n\n    // Cores para categorias (projetos) - evite vermelho, verde, azul\n    const categoryColors = [\n        \"#FF7F50\", // Coral\n        \"#FFD700\", // Ouro\n        \"#8A2BE2\", // Azul violeta\n        \"#FF69B4\", // Rosa forte\n        \"#40E0D0\", // Turquesa\n        \"#DAA520\", // Dourado\n        \"#FF8C00\", // Laranja escuro\n        \"#9932CC\", // Roxo escuro\n    ];\n\n    // Cores para status - neutras para não confundir com categorias\n    const statusColors: { [key: string]: string } = {\n        \"completed\": \"#E0E0E0\", // cinza claro\n        \"in progress\": \"#B0B0B0\", // cinza médio\n        \"not started\": \"#808080\", // cinza escuro\n    };\n\n    // Mapear projetos para cores fixas\n    const projectColorMap: { [key: string]: string } = {};\n    let colorIndex = 0;\n    for (const task of tasks) {\n        if (!projectColorMap[task.project]) {\n            projectColorMap[task.project] = categoryColors[colorIndex % categoryColors.length];\n            colorIndex++;\n        }\n    }\n\n    tasks.forEach((task, i) => {\n        const rowIdx = i + 1;\n        outputSheet.getCell(rowIdx, 0).setValue(task.project);\n        outputSheet.getCell(rowIdx, 1).setValue(task.task);\n        outputSheet.getCell(rowIdx, 2).setValue(task.status);\n\n        // Pintar célula categoria (project)\n        outputSheet.getCell(rowIdx, 0).getFormat().getFill().setColor(projectColorMap[task.project]);\n\n        // Pintar célula status\n        outputSheet.getCell(rowIdx, 2).getFormat().getFill().setColor(\n            statusColors[task.status] ?? \"#D3D3D3\"\n        );\n\n        if (task.start) {\n            // Para tarefas 'in progress', o fim é o mínimo entre hoje e a data final, ou hoje se não tiver fim\n            let taskEndDate = task.end;\n            if (task.status === \"in progress\") {\n                // Garantir que termine no máximo hoje\n                taskEndDate = task.end && task.end < today ? task.end : today;\n            }\n\n            const startOffset = Math.floor(\n                (task.start.getTime() - startDate.getTime()) / (1000 * 3600 * 24)\n            );\n            const endOffset = taskEndDate\n                ? Math.floor((taskEndDate.getTime() - startDate.getTime()) / (1000 * 3600 * 24))\n                : startOffset;\n\n            for (let d = startOffset; d <= endOffset; d++) {\n                if (d >= 0 && d <= MAX_DAYS) {\n                    const cell = outputSheet.getCell(i + 1, d + 3);\n                    cell.setValue(\"■\");\n                    cell.getFormat().getFill().setColor(projectColorMap[task.project]);\n                }\n            }\n        }\n\n    });\n\n    // Pintar o cabeçalho do dia atual\n    const todayStr = today.toLocaleDateString(\"pt-BR\");\n    const todayIdx = dateMap[todayStr];\n    if (todayIdx !== undefined) {\n        const headerCell = outputSheet.getCell(0, todayIdx + 3);\n        headerCell.getFormat().getFill().setColor(\"#FFC107\"); // Amarelo destaque\n    }\n\n    outputSheet.getUsedRange()?.getFormat().autofitColumns();\n    outputSheet.activate();\n}\n","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}